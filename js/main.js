// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Arc, Factions, NebeneinkunftMinAmounts, Rep, Viewport, deg, drawRepresentative, nebeneinkuenfteMinSum, phiAtRadius, rad, representativeParentElement, updateCheckboxLabelState, x, xPercent, y, yPercent;

  Viewport = {
    width: 800,
    height: 400
  };

  Arc = {
    innerR: 100,
    outerR: 400,
    phiMax: 180
  };

  Rep = {
    r: 5,
    spacing: 12
  };

  Factions = [
    {
      name: 'Die Linke',
      "class": 'linke'
    }, {
      name: 'SPD',
      "class": 'spd'
    }, {
      name: 'Bündnis 90/Die Grünen',
      "class": 'gruene'
    }, {
      name: 'FDP',
      "class": 'fdp'
    }, {
      name: 'CDU/CSU',
      "class": 'cducsu'
    }
  ];

  x = function(phi, r) {
    return Viewport.width / 2 - r * Math.cos(rad(phi));
  };

  y = function(phi, r) {
    return Viewport.height - r * Math.sin(rad(phi));
  };

  xPercent = function(phi, r) {
    return x(phi, r) / Viewport.width * 100;
  };

  yPercent = function(phi, r) {
    return y(phi, r) / Viewport.height * 100;
  };

  deg = function(rad) {
    return 360 * rad / (2 * Math.PI);
  };

  rad = function(deg) {
    return (2 * Math.PI) * deg / 360;
  };

  phiAtRadius = function(r) {
    return deg(Math.atan2(Rep.spacing, r));
  };

  representativeParentElement = function(rep) {
    var element, id;
    id = _.find(Factions, {
      name: rep.fraktion
    })["class"];
    if ((element = $('ul#' + id)).length > 0) {
      return element;
    }
    element = $('<ul id="' + id + '">');
    $("#parliament").append(element);
    return element;
  };

  drawRepresentative = function(rep, phi, r) {
    var element;
    element = $('<li>');
    element.addClass('representative');
    element.data('representative', rep);
    element.addClass(_.find(Factions, {
      name: rep.fraktion
    })["class"]);
    representativeParentElement(rep).append(element);
    return element[0];
  };

  updateCheckboxLabelState = function(checkbox) {
    return $(checkbox).parent('label').toggleClass('active', $(checkbox).prop('checked'));
  };

  NebeneinkunftMinAmounts = [0.01, 1000, 3500, 7000, 15000, 30000, 50000, 75000, 100000, 150000, 250000];

  nebeneinkuenfteMinSum = function(rep) {
    var sum;
    if (rep.nebeneinkuenfte.length === 0) {
      return 0;
    }
    sum = rep.nebeneinkuenfte.reduce((function(sum, einkunft) {
      return sum += NebeneinkunftMinAmounts[einkunft.level];
    }), 0);
    return Math.max(parseInt(sum, 10), 1);
  };

  $.getJSON('/data/data.json', function(data) {
    var coordinates, dataByFaction, drawOrMoveRepresentatives, faction, factionPhi, factionPhiSum, factionWidth, groupSize, hideRepresentatives, nebeneinkuenfteMinSumGroup, nebeneinkuenfteMinSumGroups, seats, totalSeats, _i, _len;
    data = data.data;
    window._data = _(data);
    _data.each(function(rep) {
      return rep.nebeneinkuenfteMinSum = nebeneinkuenfteMinSum(rep);
    });
    nebeneinkuenfteMinSumGroups = [];
    groupSize = 0;
    _data.countBy('nebeneinkuenfteMinSum').each(function(count, sum) {
      var idealGroupSize;
      idealGroupSize = data.length / (11 * (nebeneinkuenfteMinSumGroups.length + 1));
      groupSize += count;
      if (groupSize > idealGroupSize) {
        nebeneinkuenfteMinSumGroups.push(parseInt(sum, 10));
        return groupSize = 0;
      }
    });
    nebeneinkuenfteMinSumGroup = _.memoize(function(rep) {
      var index;
      index = _.findIndex(nebeneinkuenfteMinSumGroups, function(sum) {
        return rep.nebeneinkuenfteMinSum < sum;
      });
      if (index === -1) {
        index = 10;
      }
      return index;
    }, function(rep) {
      return rep.nebeneinkuenfteMinSum;
    });
    dataByFaction = _data.groupBy('fraktion').value();
    seats = _.mapValues(dataByFaction, function(f) {
      return f.length;
    });
    totalSeats = _.reduce(seats, function(sum, num) {
      return sum + num;
    });
    factionWidth = function(factionName) {
      return Arc.phiMax * (seats[factionName] / totalSeats);
    };
    factionPhi = {};
    factionPhiSum = 0;
    for (_i = 0, _len = Factions.length; _i < _len; _i++) {
      faction = Factions[_i];
      if (!dataByFaction[faction.name]) {
        continue;
      }
      factionPhi[faction.name] = factionPhiSum;
      factionPhiSum += factionWidth(faction.name);
    }
    coordinates = function(args) {
      var deltaR, emptySeatsInThisRow, fPhi, fromCenter, i, index, margin, maxIndex, phi, phiInThisRow, r, rMin, rep, seatsInThisRow;
      rep = args.forRep;
      index = args.atIndex;
      fromCenter = (10 - args.inGroup) / 10;
      maxIndex = args.ofLength - 1;
      deltaR = Arc.outerR - Arc.innerR - 2 * Rep.spacing;
      r = Arc.innerR + Rep.spacing + deltaR * fromCenter;
      i = -1;
      phi = null;
      rMin = 0;
      while (true) {
        phiInThisRow = phiAtRadius(r);
        margin = phiInThisRow;
        fPhi = factionWidth(rep.fraktion) - 2 * margin;
        seatsInThisRow = Math.ceil(fPhi / phiInThisRow);
        emptySeatsInThisRow = i + seatsInThisRow - maxIndex;
        if (emptySeatsInThisRow > 0) {
          margin -= emptySeatsInThisRow * phiInThisRow * 0.5;
        }
        if (i + seatsInThisRow >= index) {
          phi = (fPhi / Math.max(seatsInThisRow - 1, 1)) * (i + seatsInThisRow - index);
          phi += margin;
          break;
        }
        r += Rep.spacing;
        i += seatsInThisRow;
      }
      return {
        phi: phi,
        r: Math.max(r, rMin)
      };
    };
    drawOrMoveRepresentatives = function(repsByFaction) {
      var factionName, factionReps, phi, _j, _len1, _results;
      phi = 0;
      _results = [];
      for (_j = 0, _len1 = Factions.length; _j < _len1; _j++) {
        faction = Factions[_j];
        factionName = faction.name;
        factionReps = repsByFaction[factionName];
        if (!factionReps) {
          continue;
        }
        phi = factionPhi[factionName];
        _results.push(_(factionReps).groupBy(nebeneinkuenfteMinSumGroup).each(function(groupReps, group) {
          var coords, i, rep, repRadius, _k, _len2, _results1;
          _results1 = [];
          for (i = _k = 0, _len2 = groupReps.length; _k < _len2; i = ++_k) {
            rep = groupReps[i];
            coords = coordinates({
              forRep: rep,
              atIndex: i,
              inGroup: group,
              ofLength: groupReps.length
            });
            if (!rep.element) {
              rep.element = drawRepresentative(rep);
            }
            rep.visible = true;
            repRadius = Math.sqrt(Math.log(rep.nebeneinkuenfteMinSum + 1));
            _results1.push($(rep.element).removeClass('hidden').css({
              left: xPercent(phi + coords.phi, coords.r) - repRadius + "%",
              top: yPercent(phi + coords.phi, coords.r) - 2 * repRadius + "%",
              width: repRadius + "%",
              height: 2 * repRadius + "%",
              borderRadius: "50%"
            }).attr('data-group', group));
          }
          return _results1;
        }));
      }
      return _results;
    };
    hideRepresentatives = function(repsByFaction) {
      return _(repsByFaction).each(function(faction) {
        var rep, _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = faction.length; _j < _len1; _j++) {
          rep = faction[_j];
          $(rep.element).addClass('hidden');
          _results.push(rep.visible = false);
        }
        return _results;
      });
    };
    drawOrMoveRepresentatives(dataByFaction);
    $('form').on('submit', function(event) {
      var filter, form, groupedData, inputs;
      form = $(this);
      inputs = form.find('input[name]:not(:checkbox), :checkbox:checked');
      event.preventDefault();
      filter = _(inputs.get()).groupBy('name').mapValues(function(inputs) {
        return inputs.map(function(input) {
          return $(input).val();
        });
      });
      filter = filter.value();
      groupedData = _data.groupBy(function(rep) {
        return _(filter).reduce(function(sum, filterValues, filterProperty) {
          var keep;
          keep = _.contains(filterValues, rep[filterProperty]);
          return Boolean(sum * keep);
        }, true);
      });
      groupedData = groupedData.mapValues(function(reps) {
        return _.groupBy(reps, 'fraktion');
      }).value();
      if (groupedData["true"]) {
        drawOrMoveRepresentatives(groupedData["true"]);
      }
      if (groupedData["false"]) {
        return hideRepresentatives(groupedData["false"]);
      }
    });
    $('form').on('change', 'input', function() {
      $(this).submit();
      return updateCheckboxLabelState(this);
    });
    updateCheckboxLabelState($(':checkbox'));
    $(window).on('resize', function(event) {
      var aspectRatio;
      aspectRatio = Viewport.height / Viewport.width;
      return $('#parliament').css({
        height: $('#parliament').width() * aspectRatio
      });
    });
    return $(window).trigger('resize');
  });

}).call(this);


//# sourceMappingURL=main.map
