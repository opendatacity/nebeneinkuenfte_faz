// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Arc, Factions, NebeneinkunftMinAmounts, Rep, Viewport, nebeneinkuenfteMinSum, updateCheckboxLabelState;

  Viewport = {
    width: 800,
    height: 400
  };

  Arc = {
    innerR: 100,
    outerR: 400,
    phiMax: 180
  };

  Rep = {
    r: 5,
    spacing: 12
  };

  Factions = [
    {
      name: 'Die Linke',
      "class": 'linke'
    }, {
      name: 'SPD',
      "class": 'spd'
    }, {
      name: 'Bündnis 90/Die Grünen',
      "class": 'gruene'
    }, {
      name: 'FDP',
      "class": 'fdp'
    }, {
      name: 'CDU/CSU',
      "class": 'cducsu'
    }
  ];

  NebeneinkunftMinAmounts = [0.01, 1000, 3500, 7000, 15000, 30000, 50000, 75000, 100000, 150000, 250000];

  nebeneinkuenfteMinSum = function(rep) {
    var sum;
    if (rep.nebeneinkuenfte.length === 0) {
      return 0;
    }
    sum = rep.nebeneinkuenfte.reduce((function(sum, einkunft) {
      return sum += NebeneinkunftMinAmounts[einkunft.level];
    }), 0);
    return Math.max(parseInt(sum, 10), 1);
  };

  updateCheckboxLabelState = function(checkbox) {
    return $(checkbox).parent('label').toggleClass('active', $(checkbox).prop('checked'));
  };

  $.getJSON('/data/data.json', function(data) {
    var collide, dataByFaction, factionCenters, factions, force, groupSize, nebeneinkuenfteMinSumGroup, nebeneinkuenfteMinSumGroups, node, seats, svg, tick, totalSeats;
    data = data.data;
    window._data = _(data);
    factions = Factions.filter(function(faction) {
      return _data.find({
        fraktion: faction.name
      });
    });
    factionCenters = {};
    factions.forEach(function(f, i) {
      var coordinates;
      coordinates = {
        x: Viewport.width / factions.length * (0.5 + i),
        y: Viewport.height / 2
      };
      return factionCenters[f.name] = coordinates;
    });
    console.log(factionCenters);
    _data.each(function(rep) {
      rep.nebeneinkuenfteMinSum = nebeneinkuenfteMinSum(rep);
      rep.x = Viewport.width * Math.random();
      rep.y = Viewport.height * Math.random();
      return rep.radius = 5 * Math.sqrt(Math.log(rep.nebeneinkuenfteMinSum + 1));
    });
    nebeneinkuenfteMinSumGroups = [];
    groupSize = 0;
    _data.countBy('nebeneinkuenfteMinSum').each(function(count, sum) {
      var idealGroupSize;
      idealGroupSize = data.length / (11 * (nebeneinkuenfteMinSumGroups.length + 1));
      groupSize += count;
      if (groupSize > idealGroupSize) {
        nebeneinkuenfteMinSumGroups.push(parseInt(sum, 10));
        return groupSize = 0;
      }
    });
    nebeneinkuenfteMinSumGroup = _.memoize(function(rep) {
      var index;
      index = _.findIndex(nebeneinkuenfteMinSumGroups, function(sum) {
        return rep.nebeneinkuenfteMinSum < sum;
      });
      if (index === -1) {
        index = 10;
      }
      return index;
    }, function(rep) {
      return rep.nebeneinkuenfteMinSum;
    });
    dataByFaction = _data.groupBy('fraktion').value();
    seats = _.mapValues(dataByFaction, function(f) {
      return f.length;
    });
    totalSeats = _.reduce(seats, function(sum, num) {
      return sum + num;
    });
    data = _data.where(function(rep) {
      return rep.nebeneinkuenfteMinSum > 1;
    }).value();
    tick = function(e) {
      var alpha;
      alpha = e.alpha;
      data.forEach(function(rep, i) {
        var center;
        center = factionCenters[rep.fraktion];
        return collide(10)(rep);
      });
      node.attr('cx', function(d) {
        return d.x;
      });
      return node.attr('cy', function(d) {
        return d.y;
      });
    };
    collide = function(alpha) {
      var qt;
      qt = d3.geom.quadtree(data);
      return function(d) {
        var nx1, nx2, ny1, ny2, r;
        r = d.radius;
        nx1 = d.x - r;
        nx2 = d.x + r;
        ny1 = d.y - r;
        ny2 = d.y + r;
        return qt.visit(function(quad, x1, y1, x2, y2) {
          var l, x, y;
          if (quad.point && quad.point !== d) {
            x = d.x - quad.point.x;
            y = d.y - quad.point.y;
            l = Math.sqrt(x * x + y * y);
            r = d.radius + quad.point.radius;
            if (l < r) {
              l = (l - r) / l * alpha;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.point.x += x;
              quad.point.y += y;
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        });
      };
    };
    svg = d3.select('svg').attr('width', Viewport.width).attr('height', Viewport.height);
    force = d3.layout.force().nodes(data).size([Viewport.width, Viewport.height]).gravity(.05).charge(-.2).on('tick', tick).start();
    node = svg.selectAll('circle').data(data).enter().append('circle').attr('class', function(rep) {
      return _.find(factions, {
        name: rep.fraktion
      })["class"];
    }).attr('r', function(rep) {
      return rep.radius;
    }).attr('cx', function(rep) {
      return rep.x;
    }).attr('cy', function(rep) {
      return rep.y;
    }).call(force.drag);
    $('form').on('submit', function(event) {
      var filter, form, groupedData, inputs;
      form = $(this);
      inputs = form.find('input[name]:not(:checkbox), :checkbox:checked');
      event.preventDefault();
      filter = _(inputs.get()).groupBy('name').mapValues(function(inputs) {
        return inputs.map(function(input) {
          return $(input).val();
        });
      });
      filter = filter.value();
      groupedData = _data.groupBy(function(rep) {
        return _(filter).reduce(function(sum, filterValues, filterProperty) {
          var keep;
          keep = _.contains(filterValues, rep[filterProperty]);
          return Boolean(sum * keep);
        }, true);
      });
      groupedData = groupedData.mapValues(function(reps) {
        return _.groupBy(reps, 'fraktion');
      }).value();
      if (groupedData["true"]) {
        drawOrMoveRepresentatives(groupedData["true"]);
      }
      if (groupedData["false"]) {
        return hideRepresentatives(groupedData["false"]);
      }
    });
    $('form').on('change', 'input', function() {
      $(this).submit();
      return updateCheckboxLabelState(this);
    });
    updateCheckboxLabelState($(':checkbox'));
    $(window).on('resize', function(event) {
      var aspectRatio;
      aspectRatio = Viewport.height / Viewport.width;
      return $('#parliament').css({
        height: $('#parliament').width() * aspectRatio
      });
    });
    return $(window).trigger('resize');
  });

}).call(this);


//# sourceMappingURL=main.map
