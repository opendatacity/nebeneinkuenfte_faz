// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var Arc, Factions, NebeneinkunftMinAmounts, Rep, Viewport, nebeneinkuenfteMinSum, updateCheckboxLabelState;

  Viewport = {
    width: 800,
    height: 400
  };

  Arc = {
    innerR: 100,
    outerR: 400,
    phiMax: 180
  };

  Rep = {
    r: 5,
    spacing: 12
  };

  Factions = [
    {
      name: 'Die Linke',
      "class": 'linke'
    }, {
      name: 'SPD',
      "class": 'spd'
    }, {
      name: 'Bündnis 90/Die Grünen',
      "class": 'gruene'
    }, {
      name: 'FDP',
      "class": 'fdp'
    }, {
      name: 'CDU/CSU',
      "class": 'cducsu'
    }
  ];

  NebeneinkunftMinAmounts = [0.01, 1000, 3500, 7000, 15000, 30000, 50000, 75000, 100000, 150000, 250000];

  nebeneinkuenfteMinSum = function(rep) {
    var sum;
    if (rep.nebeneinkuenfte.length === 0) {
      return 0;
    }
    sum = rep.nebeneinkuenfte.reduce((function(sum, einkunft) {
      return sum += NebeneinkunftMinAmounts[einkunft.level];
    }), 0);
    return Math.max(parseInt(sum, 10), 1);
  };

  updateCheckboxLabelState = function(checkbox) {
    return $(checkbox).parent('label').toggleClass('active', $(checkbox).prop('checked'));
  };

  $.getJSON('/data/data.json', function(data) {
    var arc, collide, dataByFaction, factions, force, g, groupSize, nebeneinkuenfteMinSumGroup, nebeneinkuenfteMinSumGroups, node, parliament, pie, seats, seatsPie, svg, tick, totalSeats;
    data = data.data;
    window._data = _(data);
    factions = Factions.filter(function(faction) {
      return _data.find({
        fraktion: faction.name
      });
    });
    _data.each(function(rep) {
      rep.nebeneinkuenfteMinSum = nebeneinkuenfteMinSum(rep);
      rep.x = Viewport.width * Math.random();
      rep.y = Viewport.height * Math.random() * 0.5;
      return rep.radius = 0.07 * Math.sqrt(rep.nebeneinkuenfteMinSum);
    });
    nebeneinkuenfteMinSumGroups = [];
    groupSize = 0;
    _data.countBy('nebeneinkuenfteMinSum').each(function(count, sum) {
      var idealGroupSize;
      idealGroupSize = data.length / (11 * (nebeneinkuenfteMinSumGroups.length + 1));
      groupSize += count;
      if (groupSize > idealGroupSize) {
        nebeneinkuenfteMinSumGroups.push(parseInt(sum, 10));
        return groupSize = 0;
      }
    });
    nebeneinkuenfteMinSumGroup = _.memoize(function(rep) {
      var index;
      index = _.findIndex(nebeneinkuenfteMinSumGroups, function(sum) {
        return rep.nebeneinkuenfteMinSum < sum;
      });
      if (index === -1) {
        index = 10;
      }
      return index;
    }, function(rep) {
      return rep.nebeneinkuenfteMinSum;
    });
    dataByFaction = _data.groupBy('fraktion').value();
    seats = _.mapValues(dataByFaction, function(f) {
      return f.length;
    });
    totalSeats = _.reduce(seats, function(sum, num) {
      return sum + num;
    });
    data = _data.where(function(rep) {
      return rep.nebeneinkuenfteMinSum > 1;
    }).value();
    tick = function(e) {
      var alpha, qt;
      alpha = e.alpha * e.alpha;
      qt = d3.geom.quadtree(data);
      data.forEach(function(rep, i) {
        var dX, dY, destinationPhi, destinationX, destinationY, factionAngles, maxAngle, minAngle, missing, phi, phiOffset, r;
        dX = rep.x - (Viewport.width >> 1);
        dY = rep.y - Viewport.height;
        r = Math.sqrt(dX * dX + dY * dY);
        phi = Math.atan2(dX, -dY);
        phiOffset = Math.atan2(rep.radius, r);
        factionAngles = _.find(seatsPie, function(item) {
          return item.data.faction === rep.fraktion;
        });
        minAngle = factionAngles.startAngle;
        maxAngle = factionAngles.endAngle;
        if (r < Arc.innerR + rep.radius) {
          missing = (Arc.innerR + rep.radius - r) / r;
          rep.x += dX * missing;
          rep.y += dY * missing;
        }
        rep.phi = phi;
        rep.wrongPlacement = false;
        if (phi < minAngle + phiOffset) {
          destinationPhi = minAngle + phiOffset;
          rep.wrongPlacement = true;
        }
        if (phi > maxAngle - phiOffset) {
          destinationPhi = maxAngle - phiOffset;
          rep.wrongPlacement = true;
        }
        if (destinationPhi) {
          r = Math.max(Arc.innerR + rep.radius, r);
          dY = -r * Math.cos(destinationPhi);
          dX = r * Math.sin(destinationPhi);
          destinationX = (Viewport.width >> 1) + dX;
          destinationY = Viewport.height + dY;
          rep.x = destinationX;
          rep.y = destinationY;
        }
        return collide(0.1, qt)(rep);
      });
      node.attr('cx', function(d) {
        return d.x;
      });
      node.attr('cy', function(d) {
        return d.y;
      });
      node.classed('wrongPlacement', function(d) {
        return d.wrongPlacement;
      });
      return node.attr('data-phi', function(d) {
        return d.phi;
      });
    };
    collide = function(alpha, qt) {
      return function(d) {
        var nx1, nx2, ny1, ny2, r;
        r = d.radius;
        nx1 = d.x - r;
        nx2 = d.x + r;
        ny1 = d.y - r;
        ny2 = d.y + r;
        return qt.visit(function(quad, x1, y1, x2, y2) {
          var deltaL, h, l, w;
          if (quad.point && quad.point !== d) {
            w = d.x - quad.point.x;
            h = d.y - quad.point.y;
            l = Math.sqrt(w * w + h * h);
            r = d.radius + quad.point.radius;
            if (l < r) {
              deltaL = (l - r) / l * alpha;
              d.x -= w *= deltaL;
              d.y -= h *= deltaL;
              quad.point.x += w;
              quad.point.y += h;
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        });
      };
    };
    svg = d3.select('svg').attr('width', Viewport.width).attr('height', Viewport.height);
    pie = d3.layout.pie().sort(null).value(function(faction) {
      return faction.seats;
    }).startAngle(Math.PI * -0.5).endAngle(Math.PI * 0.5);
    seatsPie = pie(_.map(factions, function(faction) {
      return {
        faction: faction.name,
        seats: seats[faction.name]
      };
    }));
    console.log(seatsPie);
    parliament = svg.append('g').attr('width', Viewport.width).attr('height', Viewport.height).attr('transform', "translate(" + (Viewport.width / 2) + ", " + Viewport.height + ")");
    g = parliament.selectAll('.faction').data(seatsPie).enter().append('g').attr('class', function(seats) {
      return 'arc ' + _.find(factions, {
        name: seats.data.faction
      })["class"];
    });
    arc = d3.svg.arc().outerRadius(Arc.outerR).innerRadius(Arc.innerR);
    g.append('path').attr('d', arc);
    force = d3.layout.force().nodes(data).size([Viewport.width, Viewport.height * 2]).gravity(.05).charge(0).on('tick', tick).start();
    node = svg.selectAll('circle').data(data).enter().append('circle').attr('class', function(rep) {
      return _.find(factions, {
        name: rep.fraktion
      })["class"];
    }).attr('r', function(rep) {
      return rep.radius;
    }).attr('cx', function(rep) {
      return rep.x;
    }).attr('cy', function(rep) {
      return rep.y;
    });
    $('form').on('submit', function(event) {
      var filter, form, groupedData, inputs;
      form = $(this);
      inputs = form.find('input[name]:not(:checkbox), :checkbox:checked');
      event.preventDefault();
      filter = _(inputs.get()).groupBy('name').mapValues(function(inputs) {
        return inputs.map(function(input) {
          return $(input).val();
        });
      });
      filter = filter.value();
      groupedData = _data.groupBy(function(rep) {
        return _(filter).reduce(function(sum, filterValues, filterProperty) {
          var keep;
          keep = _.contains(filterValues, rep[filterProperty]);
          return Boolean(sum * keep);
        }, true);
      });
      groupedData = groupedData.mapValues(function(reps) {
        return _.groupBy(reps, 'fraktion');
      }).value();
      if (groupedData["true"]) {
        drawOrMoveRepresentatives(groupedData["true"]);
      }
      if (groupedData["false"]) {
        return hideRepresentatives(groupedData["false"]);
      }
    });
    $('form').on('change', 'input', function() {
      $(this).submit();
      return updateCheckboxLabelState(this);
    });
    updateCheckboxLabelState($(':checkbox'));
    $(window).on('resize', function(event) {
      var aspectRatio;
      aspectRatio = Viewport.height / Viewport.width;
      return $('#parliament').css({
        height: $('#parliament').width() * aspectRatio
      });
    });
    return $(window).trigger('resize');
  });

}).call(this);


//# sourceMappingURL=main.map
